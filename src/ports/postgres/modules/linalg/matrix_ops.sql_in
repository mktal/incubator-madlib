/* ----------------------------------------------------------------------- *//**
 *
 * @file matrix_ops.sql_in
 *
 * @brief Implementation of matrix operations in SQL
 * @date   April 2011
 *
 *
 *//* ----------------------------------------------------------------------- */

m4_include(`SQLCommon.m4')

/**
@addtogroup grp_matrix

<div class="toc"><b>Contents</b>
<ul>
<li class="level1"><a href="#description">Description</a></li>
<li class="level1"><a href="#operations">Matrix Operations</a></li>
<li class="level1"><a href="#glossary">Glossary of arguments</a></li>
<li class="level1"><a href="#examples">Examples</a></li>
<li class="level1"><a href="#related">Related Topics</a></li>
</ul>
</div>

@anchor description
@brief Provides fast matrix operations supporting other MADlib modules.

This module provides a set of basic matrix operations for matrices that are
too big to fit in memory. We provide two storage formats for a matrix:

- Dense: The matrix is represented as a distributed collection of 1-D arrays.
An example 3x10 matrix would be the below table:
<pre>
 row_id |         row_vec
--------+-------------------------
   1    | {9,6,5,8,5,6,6,3,10,8}
   2    | {8,2,2,6,6,10,2,1,9,9}
   3    | {3,9,9,9,8,6,3,9,5,6}
</pre>

A '<em>row</em>' column (called as <em>row_id</em> above) provides the row
number of each row and a '<em>val</em>' column (called as <em>row_vec</em>
above)  provides each row as an array. <b>The <em>row</em> column should contain a
series of integers from 1 to <em>N</em> with no duplicates,
where <em>N</em> is the  row dimensionality</b>.

- Sparse: The matrix is represented using the row and column indices for each
non-zero entry of the matrix. This representation is useful for sparse matrices,
containing multiple zero elements. Given below is an example of a sparse 4x7 matrix
with just 6 out of 28 entries being non-zero. The dimensionality of the matrix is
inferred using the max value in <em>row</em> and <em>col</em> columns. Note the
last entry is included (even though it is 0) to provide the dimensionality of the
matrix (indicating that the 4th row and 7th column contain all zeros).
<pre>
 row_id | col_id | value
--------+--------+-------
      1 |      1 |     9
      1 |      5 |     6
      1 |      6 |     6
      2 |      1 |     8
      3 |      1 |     3
      3 |      2 |     9
      4 |      7 |     0
(6 rows)
</pre>

<b>For sparse matrices, the <em>row</em> and <em>col</em> columns together should not
contain a duplicate entry and the <em>val</em> column should be of scalar
(non-array) data type</b>.
<br>
For comparison, the dense representation of this matrix is shown below. Note the
dimensionality of the dense matrix is 4 x 7 since the max value of <em>row</em>
and <em>col</em> is 4 and 7 respectively, leading to all zeros in the last row
and last column.
&nbsp;
<pre>
 row_id |         row_vec
--------+-------------------------
   1    | {9,0,0,0,6,6,0}
   2    | {8,0,0,0,0,0,0}
   3    | {3,9,0,0,0,0,0}
   4    | {0,0,0,0,0,0,0}
</pre>

@note The functions below support several numeric types (unless otherwise noted)
including SMALLINT, INTEGER, BIGINT, DOUBLE PRECISION (FLOAT8), NUMERIC
(internally casted into FLOAT8, loss of precision can happen).

@anchor operations
@par  Matrix Operations

Given below are the supported matrix operations. The meaning of the arguments
and other terms are common to all functions and provided at the end of the list
as a glossary.

- \b Representation
<pre class="syntax">
-- Convert to sparse representation
&nbsp; <b>matrix_sparsify</b>( matrix_in, in_args, matrix_out, out_args)
&nbsp;
-- Convert to dense representation
&nbsp; <b>matrix_densify</b>( matrix_in, in_args, matrix_out, out_args)
</pre>

- <b>Mathematical operations</b>
<pre class="syntax">
-- Matrix transposition
&nbsp; <b>matrix_trans</b>( matrix_in, in_args, matrix_out, out_args)
&nbsp;
-- Matrix addition
&nbsp; <b>matrix_add</b>( matrix_a, a_args, matrix_b, b_args, matrix_out, out_args)
&nbsp;
-- Matrix subtraction
&nbsp; <b>matrix_sub</b>( matrix_a, a_args, matrix_b, b_args, matrix_out, out_args)
&nbsp;
-- Matrix multiplication
&nbsp; <b>matrix_mult</b>( matrix_a, a_args, matrix_b, b_args, matrix_out, out_args)
&nbsp;
-- Element-wise matrix multiplication
&nbsp; <b>matrix_elem_mult</b>( matrix_a, a_args, matrix_b, b_args, matrix_out, out_args)
&nbsp;
-- Multiply matrix with scalar.
&nbsp; <b>matrix_scalar_mult</b>( matrix_in, in_args, scalar, matrix_out, out_args)
&nbsp;
-- Multiply matrix with vector.
&nbsp; <b>matrix_vec_mult</b>( matrix_in, in_args, vector)
</pre>

- <b>Extraction/visitor methods</b>
<pre class="syntax">
-- Extract row from matrix given row index
&nbsp; <b>matrix_extract_row</b>( matrix_in, in_args, index)
&nbsp;
-- Extract column from matrix given column index
&nbsp; <b>matrix_extract_col</b>( matrix_in, in_args, index)
</pre>

- <b>Reduction operations (aggregate across specific dimension)</b>
<pre class="syntax">
-- Get max value along dim. Also returns corresponding index if <em>fetch_index</em> = True
&nbsp; <b>matrix_max</b>( matrix_in, in_args, dim, matrix_out, fetch_index)
&nbsp;
-- Get min value along dim. Also returns corresponding index if <em>fetch_index</em> = True
&nbsp; <b>matrix_min</b>( matrix_in, in_args, dim, matrix_out, fetch_index)
&nbsp;
-- Get sum value along dimension from matrix.
&nbsp; <b>matrix_sum</b>( matrix_in, in_args, dim)
&nbsp;
-- Get mean value along dimension from matrix.
&nbsp; <b>matrix_mean</b>( matrix_in, in_args, dim)
</pre>

@anchor glossary
\b Glossary

The table below provides a glossary of the terms used in the matrix operations.

<dl class="arglist">
<dt>matrix_in, matrix_a, matrix_b</dt>
<dd>TEXT. Name of the table containing the input matrix.
- For functions accepting one matrix, <em>matrix_in</em> denotes the input matrix.
- For functions accepting two matrices, <em>matrix_a</em> denotes the first matrix
and <em>matrix_b</em> denotes the second matrix. These two matrices can
<b>independently</b> be in either dense or sparse format.
</dd>

<dt>in_args, a_args, b_args</dt>
<dd>TEXT. A comma-delimited string containing multiple named arguments of the form "name=value".
This argument is used as a container for multiple parameters related to a single
matrix.

The following parameters are supported for this string argument:
<table class="output">
<tr>
    <th>row</th>
    <td>(Default: 'row_num') Name of the column containing row index of the matrix. </td>
</tr>
<tr>
    <th>col</th>
    <td>(Default: 'col_num') Name of the column containing column index of the matrix.</td>
</tr>
<tr>
    <th>val</th>
    <td>(Default: 'val') Name of the column containing the entries of the matrix.</td>
</tr>
<tr>
    <th>trans</th>
    <td>(Default: False) Boolean flag to indicate if the matrix should be
        transposed before the operation. This is currently functional only for <em>matrix_mult</em>.</td>
</tr>
</table>

For example, the string argument with default values will be
'row=row_num, col=col_num, val=val, trans=False'. Alternatively,
the string argument can be set to <em>NULL</em> or be blank ('') if default
values are to be used.
</dd>

<dt>matrix_out</dt>
<dd>TEXT. Name of the table to store the result matrix. </dd>

<dt>out_args</dt>
<dd> TEXT. A comma-delimited string containing named arguments of the form
"name=value". This is an <b>optional parameter</b> and the default value is set as follows:
    - For functions with one input matrix, default = <em>in_args</em>
    - For functions with two input matrices, default = <em>a_args</em>.

The following parameters are supported for this string argument:
<table class="output">
<tr>
    <th>row</th>
    <td> Name of the column containing row index of the matrix. </td>
</tr>
<tr>
    <th>col</th>
    <td> Name of the column containing column index of the matrix.</td>
</tr>
<tr>
    <th>val</th>
    <td> Name of the column containing the entries of the matrix.</td>
</tr>
</table>

<dt>index</dt>
<dd> INTEGER. An integer representing a row or column index of the matrix.
Should be a number from 1 to <em>N</em>, where <em>N</em> is the maximum size of the
dimension.</dd>

<dt>dim</dt>
<dd> INTEGER. Should either be 1 or 2. This value indicates the dimension to operate along
for the reduction/aggregation operations. <b>The value of <em>dim</em> should be interpreted as
the dimension to be flattened i.e. whose length reduces to 1 in the result.</b>
<br>
For <em>dim=1</em>, a reduction function
on an <em>NxM</em> matrix operates on successive elements in each column and
returns a single vector with <em>M</em> elements (i.e. matrix with just 1 row
and <em>M</em> columns).
<br>
For <em>dim=2</em>, a single vector is returned with
<em>N</em> elements (i.e. matrix with just 1 column and <em>N</em> rows).
</dd>

</dd>
</dl>

- Convert sparse matrix to svec format
<pre class="syntax">
matrix_sparse_to_svec( matrix_in, in_args,
             matrix_out, out_args)
</pre>

- Convert svec format matrix to sparse matrix
<pre class="syntax">
matrix_svec_to_sparse( matrix_in, in_args,
             matrix_out, out_args)
</pre>

- Convert dense matrix to svec format
<pre class="syntax">
matrix_dense_to_svec( matrix_in, in_args,
             matrix_out, out_args)
</pre>

- Convert svec format matrix to dense matrix
<pre class="syntax">
matrix_svec_to_dense( matrix_in, in_args,
             matrix_out, out_args)
</pre>
@anchor examples
@par Examples

- Create some random data tables in dense format.
<pre class="syntax">
CREATE TABLE "mat_A" (
    row_id integer,
    row_vec integer[]
);
INSERT INTO "mat_A" (row_id, row_vec) VALUES (1, '{9,6,5,8,5,6,6,3,10,8}');
INSERT INTO "mat_A" (row_id, row_vec) VALUES (2, '{8,2,2,6,6,10,2,1,9,9}');
INSERT INTO "mat_A" (row_id, row_vec) VALUES (3, '{3,9,9,9,8,6,3,9,5,6}');
INSERT INTO "mat_A" (row_id, row_vec) VALUES (4, '{6,4,2,2,2,7,8,8,0,7}');
INSERT INTO "mat_A" (row_id, row_vec) VALUES (5, '{6,8,9,9,4,6,9,5,7,7}');
INSERT INTO "mat_A" (row_id, row_vec) VALUES (6, '{4,10,7,3,9,5,9,2,3,4}');
INSERT INTO "mat_A" (row_id, row_vec) VALUES (7, '{8,10,7,10,1,9,7,9,8,7}');
INSERT INTO "mat_A" (row_id, row_vec) VALUES (8, '{7,4,5,6,2,8,1,1,4,8}');
INSERT INTO "mat_A" (row_id, row_vec) VALUES (9, '{8,8,8,5,2,6,9,1,8,3}');
INSERT INTO "mat_A" (row_id, row_vec) VALUES (10, '{4,6,3,2,6,4,1,2,3,8}');
\nbsp
CREATE TABLE "mat_B" (
    row_id integer,
    vector integer[]
);
INSERT INTO "mat_B" (row_id, vector) VALUES (1, '{9,10,2,4,6,5,3,7,5,6}');
INSERT INTO "mat_B" (row_id, vector) VALUES (2, '{5,3,5,2,8,6,9,7,7,6}');
INSERT INTO "mat_B" (row_id, vector) VALUES (3, '{0,1,2,3,2,7,7,3,10,1}');
INSERT INTO "mat_B" (row_id, vector) VALUES (4, '{2,9,0,4,3,6,8,6,3,4}');
INSERT INTO "mat_B" (row_id, vector) VALUES (5, '{3,8,7,7,0,5,3,9,2,10}');
INSERT INTO "mat_B" (row_id, vector) VALUES (6, '{5,3,1,7,6,3,5,3,6,4}');
INSERT INTO "mat_B" (row_id, vector) VALUES (7, '{4,8,4,4,2,7,10,0,3,3}');
INSERT INTO "mat_B" (row_id, vector) VALUES (8, '{4,6,0,1,3,1,6,6,9,8}');
INSERT INTO "mat_B" (row_id, vector) VALUES (9, '{6,5,1,7,2,7,10,6,0,6}');
INSERT INTO "mat_B" (row_id, vector) VALUES (10, '{1,4,4,4,8,5,2,8,5,5}');
</pre>

- Transpose a matrix
<pre class="syntax">
SELECT madlib.matrix_trans('"mat_B"', 'row=row_id, val=vector',
                           'mat_r');
SELECT * FROM mat_r ORDER BY row_id;
</pre>
<pre class="result">
-- Note the result matrix has inherited 'vector' as the name of value column
 row_id |         vector
\--------+-------------------------
      1 | {9,5,0,2,3,5,4,4,6,1}
      2 | {10,3,1,9,8,3,8,6,5,4}
      3 | {2,5,2,0,7,1,4,0,1,4}
      4 | {4,2,3,4,7,7,4,1,7,4}
      5 | {6,8,2,3,0,6,2,3,2,8}
      6 | {5,6,7,6,5,3,7,1,7,5}
      7 | {3,9,7,8,3,5,10,6,10,2}
      8 | {7,7,3,6,9,3,0,6,6,8}
      9 | {5,7,10,3,2,6,3,9,0,5}
      10 | {6,6,1,4,10,4,3,8,6,5}
(10 rows)
</pre>

- Add the two matrices
<pre class="syntax">
SELECT madlib.matrix_add('"mat_A"', 'row=row_id, val=row_vec',
                         '"mat_B"', 'row=row_id, val=vector',
                         'mat_r', 'val=vector');
SELECT * FROM mat_r ORDER BY row_id;
</pre>
<pre class="result">
 row_id |            vector
\--------+-------------------------------
      1 | {18,16,7,12,11,11,9,10,15,14}
      2 | {13,5,7,8,14,16,11,8,16,15}
      3 | {3,10,11,12,10,13,10,12,15,7}
      4 | {8,13,2,6,5,13,16,14,3,11}
      5 | {9,16,16,16,4,11,12,14,9,17}
      6 | {9,13,8,10,15,8,14,5,9,8}
      7 | {12,18,11,14,3,16,17,9,11,10}
      8 | {11,10,5,7,5,9,7,7,13,16}
      9 | {14,13,9,12,4,13,19,7,8,9}
      10 | {5,10,7,6,14,9,3,10,8,13}
(10 rows)
</pre>

- Multiply the two matrices
<pre class="syntax">
DROP TABLE IF EXISTS mat_r;
SELECT madlib.matrix_mult('"mat_A"', 'row=row_id, val=row_vec',
                          '"mat_B"', 'row=row_id, val=vector, trans=true',
                          'mat_r');
SELECT * FROM mat_r ORDER BY row_id;
</pre>
<pre class="result">
 row_id |                  row_vec
\--------+-------------------------------------------
     1  | {380,373,251,283,341,303,302,309,323,281}
     2  | {318,318,222,221,269,259,236,249,264,248}
     3  | {382,366,216,300,397,276,277,270,313,338}
     4  | {275,284,154,244,279,183,226,215,295,204}
     5  | {381,392,258,319,394,298,342,302,360,300}
     6  | {321,333,189,276,278,232,300,236,281,250}
     7  | {443,411,282,365,456,318,360,338,406,330}
     8  | {267,240,150,186,270,194,210,184,233,193}
     9  | {322,328,234,264,291,245,317,253,291,219}
     10 | {246,221,109,173,222,164,167,185,181,189}
(10 rows)
</pre>

- Extract row and column from matrix given index
<pre class="syntax">
SELECT madlib.matrix_extract_row('"mat_A"', 'row=row_id, val=row_vec', 2) as row,
       madlib.matrix_extract_col('"mat_A"', 'row=row_id, val=row_vec', 3) as col;
</pre>
<pre class="result">
          row           |          col
\------------------------+-----------------------
 {8,2,2,6,6,10,2,1,9,9} | {5,2,9,2,9,7,7,5,8,3}
(1 rows)
</pre>

- Get min and max values along a specific dimension as well as corresponding indicies.
Note that <em>dim=2</em> implies that the min and max is computed on each row
returning a column vector i.e. the column (dim=2) is flattened.
<pre class="syntax">
SELECT madlib.matrix_max('"mat_A"', 'row=row_id, val=row_vec', 2, 'mat_max_r', true),
       madlib.matrix_min('"mat_A"', 'row=row_id, val=row_vec', 2, 'mat_min_r', true);
SELECT * from mat_max_r;
SELECT * from mat_min_r;
</pre>
<pre class="result">
         index         |            max
\-----------------------+---------------------------
 {8,5,1,6,2,1,1,5,6,9} | {10,10,9,8,9,10,10,8,9,8}
(1 rows)
&nbsp;
         index         |          min
\-----------------------+-----------------------
 {7,7,0,8,4,7,4,6,7,6} | {3,1,3,0,4,2,1,1,1,1}
(1 rows)
</pre>

- Element-wise multiplication between two matrices
<pre class="syntax">
SELECT madlib.matrix_elem_mult('"mat_A"', 'row=row_id, val=row_vec',
                               '"mat_B"', 'val=vector',
                               'mat_r', 'val=vector');
SELECT * FROM mat_r ORDER BY row_id;
</pre>
<pre class="result">
 row_id |             vector
\--------+---------------------------------
     1  | {81,60,10,32,30,30,18,21,50,48}
     2  | {40,6,10,12,48,60,18,7,63,54}
     3  | {0,9,18,27,16,42,21,27,50,6}
     4  | {12,36,0,8,6,42,64,48,0,28}
     5  | {18,64,63,63,0,30,27,45,14,70}
     6  | {20,30,7,21,54,15,45,6,18,16}
     7  | {32,80,28,40,2,63,70,0,24,21}
     8  | {28,24,0,6,6,8,6,6,36,64}
     9  | {48,40,8,35,4,42,90,6,0,18}
     10 | {4,24,12,8,48,20,2,16,15,40}
</pre>

- Get sum values along dimension. Sum is computed for each row (i.e. column is flattened since dim=2)
<pre class="syntax">
SELECT madlib.matrix_sum('"mat_A"', 'row=row_id, val=row_vec', 2);
</pre>
<pre class="result">
           matrix_sum
\---------------------------------
 {66,55,67,46,70,56,76,46,58,39}
(1 rows)
</pre>

- Multiply matrix with a scalar
<pre class="syntax">
DROP TABLE IF EXISTS mat_r;
SELECT madlib.matrix_scalar_mult('"mat_A"', 'row=row_id, val=row_vec', 3, 'mat_r');
SELECT * FROM mat_r ORDER BY row_id;
</pre>
<pre class="result">
 row_id |             row_vec
\--------+---------------------------------
      0 | {27,18,15,24,15,18,18,9,30,24}
      1 | {24,6,6,18,18,30,6,3,27,27}
      2 | {9,27,27,27,24,18,9,27,15,18}
      3 | {18,12,6,6,6,21,24,24,0,21}
      4 | {18,24,27,27,12,18,27,15,21,21}
      5 | {12,30,21,9,27,15,27,6,9,12}
      6 | {24,30,21,30,3,27,21,27,24,21}
      7 | {21,12,15,18,6,24,3,3,12,24}
      8 | {24,24,24,15,6,18,27,3,24,9}
      9 | {12,18,9,6,18,12,3,6,9,24}
(10 rows)
</pre>

- Multiply matrix with a vector
<pre class="syntax">
SELECT madlib.matrix_vec_mult('"mat_A"', 'row=row_id, val=row_vec',
                              array[1,2,3,4,5,6,7,8,9,10]);
</pre>
<pre class="result">
              matrix_vec_mult
\-------------------------------------------
 {365,325,358,270,377,278,411,243,287,217}
(10 rows)
</pre>

- <b>Examples with sparse representation</b>. The function calls are the same as before.
<pre class="syntax">
SELECT madlib.matrix_sparsify('"mat_B"', 'row=row_id, val=vector',
                              '"mat_B_sparse"', 'col=col_id, val=val');
</pre>

- Create a matrix in sparse format.
<pre class="syntax">
CREATE TABLE "mat_A_sparse" (
    "rowNum" integer,
    col_num integer,
    entry integer
);
INSERT INTO "mat_A_sparse" ("rowNum", col_num, entry) VALUES (1, 1, 9);
INSERT INTO "mat_A_sparse" ("rowNum", col_num, entry) VALUES (1, 2, 6);
INSERT INTO "mat_A_sparse" ("rowNum", col_num, entry) VALUES (1, 7, 3);
INSERT INTO "mat_A_sparse" ("rowNum", col_num, entry) VALUES (1, 8, 10);
INSERT INTO "mat_A_sparse" ("rowNum", col_num, entry) VALUES (1, 9, 8);
INSERT INTO "mat_A_sparse" ("rowNum", col_num, entry) VALUES (2, 1, 8);
INSERT INTO "mat_A_sparse" ("rowNum", col_num, entry) VALUES (2, 2, 2);
INSERT INTO "mat_A_sparse" ("rowNum", col_num, entry) VALUES (2, 3, 6);
INSERT INTO "mat_A_sparse" ("rowNum", col_num, entry) VALUES (3, 5, 6);
INSERT INTO "mat_A_sparse" ("rowNum", col_num, entry) VALUES (3, 6, 3);
INSERT INTO "mat_A_sparse" ("rowNum", col_num, entry) VALUES (7, 1, 7);
INSERT INTO "mat_A_sparse" ("rowNum", col_num, entry) VALUES (8, 2, 8);
INSERT INTO "mat_A_sparse" ("rowNum", col_num, entry) VALUES (8, 3, 5);
INSERT INTO "mat_A_sparse" ("rowNum", col_num, entry) VALUES (9, 1, 6);
INSERT INTO "mat_A_sparse" ("rowNum", col_num, entry) VALUES (9, 2, 3);
INSERT INTO "mat_A_sparse" ("rowNum", col_num, entry) VALUES (10, 10, 0);
</pre>

- Create a matrix in dense format
<pre class="syntax">
CREATE TABLE "mat_A_dense" (
    "row_id" integer,
    vec float[8]
);
INSERT INTO "mat_A_dense" VALUES (1,'{9,6,0,0,0,0,3,10,8}');
INSERT INTO "mat_A_dense" VALUES (2,'{8,2,6,0,0,0,0,0,0}');
INSERT INTO "mat_A_dense" VALUES (3,'{0,0,0,0,6,3,0,0,0}');
INSERT INTO "mat_A_dense" VALUES (4,'{0,0,0,0,0,0,0,0,0}');
INSERT INTO "mat_A_dense" VALUES (5,'{0,0,0,0,0,0,0,0,0}');
INSERT INTO "mat_A_dense" VALUES (6,'{0,0,0,0,0,0,0,0,0}');
INSERT INTO "mat_A_dense" VALUES (7,'{7,0,0,0,0,0,0,0,0}');
INSERT INTO "mat_A_dense" VALUES (8,'{0,8,5,0,0,0,0,0,0}');
INSERT INTO "mat_A_dense" VALUES (9,'{6,3,0,0,0,0,0,0,0}');
</pre>


- Create a matrix in svec format.
<pre class="syntax">
CREATE TABLE "mat_A_svec" (
    "row_id" integer,
    svec madlib.svec
);
INSERT INTO "mat_A_svec" VALUES (1,'{1,1,4,1,1,1}:{9,6,0,3,10,8}'::madlib.svec);
INSERT INTO "mat_A_svec" VALUES (2,'{1,1,1,6}:{8,2,6,0}'::madlib.svec);
INSERT INTO "mat_A_svec" VALUES (3,'{4,1,1,3}:{0,6,3,0}'::madlib.svec);
INSERT INTO "mat_A_svec" VALUES (4,'{9}:{0}'::madlib.svec);
INSERT INTO "mat_A_svec" VALUES (5,'{9}:{0}'::madlib.svec);
INSERT INTO "mat_A_svec" VALUES (6,'{9}:{0}'::madlib.svec);
INSERT INTO "mat_A_svec" VALUES (7,'{1,8}:{7,0}'::madlib.svec);
INSERT INTO "mat_A_svec" VALUES (8,'{1,1,1,6}:{0,8,5,0}'::madlib.svec);
INSERT INTO "mat_A_svec" VALUES (9,'{1,1,7}:{6,3,0}'::madlib.svec);
</pre>

- Transpose a matrix in sparse format
<pre class="syntax">
-- Note the double quotes for '"rowNum"' required per PostgreSQL rules
SELECT madlib.matrix_trans('"mat_A_sparse"', 'row="rowNum", val=entry',
                           'matrix_r_sparse');
SELECT "rowNum", col_num, entry FROM matrix_r_sparse ORDER BY col_num;
</pre>
<pre class="result">
 rowNum | col_num | entry
--------+---------+-------
      1 |       1 |     9
      2 |       1 |     6
      7 |       1 |     3
      8 |       1 |    10
      9 |       1 |     8
      1 |       2 |     8
      2 |       2 |     2
      3 |       2 |     6
      5 |       3 |     6
      6 |       3 |     3
      1 |       7 |     7
      2 |       8 |     8
      3 |       8 |     5
      1 |       9 |     6
      2 |       9 |     3
     10 |      10 |     0
(16 rows)
</pre>

- Add two sparse matrices
<pre class="syntax">
SELECT madlib.matrix_add('"mat_A_sparse"', 'row="rowNum", val=entry',
                         '"mat_B_sparse"', 'row=row_id, col=col_id, val=val',
                         'matrix_r_sparse', 'col=col_out');
SELECT madlib.matrix_densify('matrix_r_sparse', 'row="rowNum", col=col_out, val=entry',
                             'matrix_r');
SELECT * FROM matrix_r ORDER BY "rowNum";
</pre>
<pre class="result">
 rowNum |           entry
--------+---------------------------
      1 | {18,16,2,4,6,5,6,17,13,6}
      2 | {13,5,11,2,8,6,9,7,7,6}
      3 | {0,1,2,3,8,10,7,3,10,1}
      4 | {2,9,0,4,3,6,8,6,3,4}
      5 | {3,8,7,7,0,5,3,9,2,10}
      6 | {5,3,1,7,6,3,5,3,6,4}
      7 | {11,8,4,4,2,7,10,0,3,3}
      8 | {4,14,5,1,3,1,6,6,9,8}
      9 | {12,8,1,7,2,7,10,6,0,6}
     10 | {1,4,4,4,8,5,2,8,5,5}
(10 rows)
</pre>

- Multiply two sparse matrices
<pre class="syntax">
SELECT madlib.matrix_mult('"mat_A_sparse"', 'row="rowNum", col=col_num, val=entry',
                          '"mat_B_sparse"', 'row=row_id, col=col_id, val=val, trans=true',
                          'matrix_r');
SELECT * FROM matrix_r ORDER BY "rowNum";
</pre>
<pre class="result">
 rowNum |                   entry
--------+-------------------------------------------
      1 | {260,216,137,180,190,156,138,222,174,159}
      2 | {104,76,14,34,82,52,72,44,64,40}
      3 | {51,66,33,36,15,45,33,21,33,63}
      4 | {0,0,0,0,0,0,0,0,0,0}
      5 | {0,0,0,0,0,0,0,0,0,0}
      6 | {0,0,0,0,0,0,0,0,0,0}
      7 | {63,35,0,14,21,35,28,28,42,7}
      8 | {90,49,18,72,99,29,84,48,45,52}
      9 | {84,39,3,39,42,39,48,42,51,18}
     10 | {0,0,0,0,0,0,0,0,0,0}
(10 rows)
</pre>

- Convert sparse matrix to svec format
<pre class="syntax">
SELECT madlib.matrix_sparse_to_svec('"mat_A_sparse"', 'row="rowNum", col=col_num, val=entry',
                                    'mat_r', 'row=row_id, val=svec');
SELECT * FROM mat_r ORDER BY row_id;
<pre class="result">
 row_id |                   svec
--------+-------------------------------------------
      1 | {1,1,4,1,1,1}:{9,6,0,3,10,8}
      2 | {1,1,1,6}:{8,2,6,0}
      3 | {4,1,1,3}:{0,6,3,0}
      4 | {9}:{0} 
      5 | {9}:{0} 
      6 | {9}:{0} 
      7 | {1,8}:{7,0}
      8 | {1,1,1,6}:{0,8,5,0} 
      9 | {1,1,7}:{6,3,0}
(10 rows)
</pre>

- Convert svec format matrix to sparse matrix
<pre class="syntax">
matrix_svec_to_sparse( '"mat_A_svec"', 'row="row_id",val=svec',
             'mat_r', 'row=row_id, col=col_id,val=val');
SELECT * FROM mat_r ORDER BY row_id;
<pre class="result">
 row_id | col_id  |   val
--------+---------+-------
      1 |       2 |     6
      1 |       1 |     9
      1 |       8 |    10
      1 |       9 |     8
      1 |       7 |     3
      2 |       2 |     2
      2 |       1 |     8
      2 |       3 |     6
      3 |       5 |     6
      3 |       6 |     3
      7 |       1 |     7
      8 |       2 |     8
      8 |       3 |     5
      9 |       2 |     3
      9 |       1 |     6
(15 rows)
</pre>

- Convert dense matrix to svec format
<pre class="syntax">
SELECT madlib.matrix_dense_to_svec('"matrix_A_dense"', 'row=row_id, val=vec',
             'mat_r', 'row=row_id,val=svec');
SELECT * FROM mat_r ORDER BY row_id;
<pre class="result">
 row_id |                   svec
--------+-------------------------------------------
      1 | {1,1,4,1,1,1}:{9,6,0,3,10,8}
      2 | {1,1,1,6}:{8,2,6,0}
      3 | {4,1,1,3}:{0,6,3,0}
      4 | {9}:{0} 
      5 | {9}:{0} 
      6 | {9}:{0} 
      7 | {1,8}:{7,0}
      8 | {1,1,1,6}:{0,8,5,0} 
      9 | {1,1,7}:{6,3,0}
(10 rows)
</pre>

- Convert svec format matrix to dense matrix
<pre class="syntax">
SELECT madlib.matrix_svec_to_dense( '"mat_A_svec, 'row=row_id,val=svec',
             'mat_r', 'row=row_id,val=vec');
SELECT * FROM mat_r ORDER BY row_id;
<pre class="result">
 row_id |         vec
--------+----------------------
      1 | {9,6,0,0,0,0,3,10,8}
      2 | {8,2,6,0,0,0,0,0,0}
      3 | {0,0,0,0,6,3,0,0,0}
      4 | {0,0,0,0,0,0,0,0,0}
      5 | {0,0,0,0,0,0,0,0,0}
      6 | {0,0,0,0,0,0,0,0,0}
      7 | {7,0,0,0,0,0,0,0,0}
      8 | {0,8,5,0,0,0,0,0,0}
      9 | {6,3,0,0,0,0,0,0,0}
(9 rows)
</pre>
@anchor related
@par Related Topics

File array_ops.sql_in documenting the array operations
\ref grp_array

File matrix_ops.sql_in for list of functions and usage.
*/
-------------------------------------------------------------------------

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.matrix_info(
    message     TEXT
) RETURNS TEXT AS $$
PythonFunction(linalg, matrix_help_message, matrix_info_help_message)
$$ LANGUAGE plpythonu IMMUTABLE
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `CONTAINS SQL', `');


CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.matrix_info()
RETURNS TEXT AS $$
BEGIN
    RETURN MADLIB_SCHEMA.matrix_info('');
END;
$$ LANGUAGE plpgsql IMMUTABLE
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `CONTAINS SQL', `');
-------------------------------------------------------------------------

DROP TYPE IF EXISTS MADLIB_SCHEMA.matrix_result CASCADE;
CREATE TYPE MADLIB_SCHEMA.matrix_result AS(
    output_table    TEXT
);

/**
 * @brief Multiplies two matrices. It requires that all the values are NON-NULL.
 * This is the sparse representation of the matrix where the matrix elements
 * are indexed by the row and column index.
 *
 * @param matrix_a Name of the table containing the first matrix
 * @param a_row Name of the column containing the row index for the first matrix
 * @param a_col Name of the column containing the column index for the first matrix
 * @param a_val Name of the column containing the matrix values for the first matrix
 * @param a_trans Boolean to indicate if first matrix should be transposed before multiplication
 * @param matrix_b Name of the table containing the second matrix
 * @param b_row Name of the column containing the row index for the second matrix
 * @param b_col Name of the column containing the column index for the second matrix
 * @param b_val Name of the column containing the matrix values for the second matrix
 * @param b_trans Boolean to indicate if second matrix should be transposed before multiplication
 * @param matrix_out Name of the table where to output the result matrix
 * @returns Name of the table containing the result matrix
 *
 */
CREATE OR REPLACE FUNCTION
MADLIB_SCHEMA.matrix_mult
(
    matrix_a    TEXT,
    a_args      TEXT,
    matrix_b    TEXT,
    b_args      TEXT,
    matrix_out  TEXT,
    out_args    TEXT
)
RETURNS MADLIB_SCHEMA.matrix_result AS $$
    PythonFunctionBodyOnly(`linalg', `matrix_ops')
    matrix_ops.matrix_mult(schema_madlib,
        matrix_a, a_args,
        matrix_b, b_args,
        matrix_out, out_args)
    return [matrix_out]
$$ LANGUAGE plpythonu
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `MODIFIES SQL DATA', `');

CREATE OR REPLACE FUNCTION
MADLIB_SCHEMA.matrix_mult
(
    matrix_a        TEXT,
    a_args          TEXT,
    matrix_b        TEXT,
    b_args          TEXT,
    matrix_out      TEXT
)
RETURNS MADLIB_SCHEMA.matrix_result AS $$
    SELECT
        MADLIB_SCHEMA.matrix_mult(
            $1, $2, $3, $4, $5, NULL);
$$ LANGUAGE sql
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `MODIFIES SQL DATA', `');

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.matrix_mult(
    message     TEXT
) RETURNS TEXT AS $$
PythonFunction(linalg, matrix_help_message, matrix_mult_help_message)
$$ LANGUAGE plpythonu IMMUTABLE
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `CONTAINS SQL', `');

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.matrix_mult()
RETURNS TEXT AS $$
BEGIN
    RETURN MADLIB_SCHEMA.matrix_mult('');
END;
$$ LANGUAGE plpgsql IMMUTABLE
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `CONTAINS SQL', `');

-------------------------------------------------------------------------

/**
 * @brief Adds two matrices. It requires that all the values are NON-NULL.
 * This is the sparse representation of the matrix where the matrix elements
 * are indexed by the row and column index.
 *
 * @param matrix_a Name of the table containing the first matrix
 * @param a_row Name of the column containing the row index for the first matrix
 * @param a_col Name of the column containing the column index for the first matrix
 * @param a_val Name of the column containing the matrix values for the first matrix
 * @param matrix_b Name of the table containing the second matrix
 * @param b_row Name of the column containing the row index for the second matrix
 * @param b_col Name of the column containing the column index for the second matrix
 * @param b_val Name of the column containing the matrix values for the second matrix
 * @param matrix_out Name of the table where to output the result matrix
 * @returns Name of the table containing the result matrix
 *
 */
CREATE OR REPLACE FUNCTION
MADLIB_SCHEMA.matrix_add
(
    matrix_a    TEXT,
    a_args      TEXT,
    matrix_b    TEXT,
    b_args      TEXT,
    matrix_out  TEXT,
    out_args    TEXT
)
RETURNS MADLIB_SCHEMA.matrix_result AS $$
    PythonFunctionBodyOnly(`linalg', `matrix_ops')
    matrix_ops.matrix_add(schema_madlib,
        matrix_a, a_args,
        matrix_b, b_args,
        matrix_out, out_args)
    return [matrix_out]
$$ LANGUAGE plpythonu
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `MODIFIES SQL DATA', `');

CREATE OR REPLACE FUNCTION
MADLIB_SCHEMA.matrix_add
(
    matrix_a    TEXT,
    a_args      TEXT,
    matrix_b    TEXT,
    b_args      TEXT,
    matrix_out  TEXT
)
RETURNS MADLIB_SCHEMA.matrix_result AS $$
    SELECT MADLIB_SCHEMA.matrix_add($1, $2, $3, $4, $5, ''::TEXT)
$$ LANGUAGE SQL
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `MODIFIES SQL DATA', `');


CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.matrix_add(
    message     TEXT
) RETURNS TEXT AS $$
PythonFunction(linalg, matrix_help_message, matrix_add_help_message)
$$ LANGUAGE plpythonu IMMUTABLE
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `CONTAINS SQL', `');

CREATE OR REPLACE FUNCTION
MADLIB_SCHEMA.matrix_add
(
    matrix_a        TEXT,
    a_args          TEXT,
    matrix_b        TEXT,
    b_args          TEXT,
    matrix_out      TEXT
)
RETURNS MADLIB_SCHEMA.matrix_result AS $$
    SELECT
        MADLIB_SCHEMA.matrix_add(
            $1, $2, $3, $4, $5, NULL);
$$ LANGUAGE sql
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `MODIFIES SQL DATA', `');


CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.matrix_add()
RETURNS TEXT AS $$
BEGIN
    RETURN MADLIB_SCHEMA.matrix_add('');
END;
$$ LANGUAGE plpgsql IMMUTABLE
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `CONTAINS SQL', `');

-------------------------------------------------------------------------

/**
 * @brief Subs two matrices. It requires that all the values are NON-NULL.
 * This is the sparse representation of the matrix where the matrix elements
 * are indexed by the row and column id.
 *
 * @param matrix_a Name of the table containing the first matrix
 * @param a_row Name of the column containing the row id for the first matrix
 * @param a_col Name of the column containing the column id for the first matrix
 * @param a_val Name of the column containing the matrix values for the first matrix
 * @param matrix_b Name of the table containing the second matrix
 * @param b_row Name of the column containing the row id for the second matrix
 * @param b_col Name of the column containing the column id for the second matrix
 * @param b_val Name of the column containing the matrix values for the second matrix
 * @param matrix_out Name of the table where to output the result matrix
 * @returns Name of the table containing the result matrix
 *
 */
CREATE OR REPLACE FUNCTION
MADLIB_SCHEMA.matrix_sub
(
    matrix_a    TEXT,
    a_args      TEXT,
    matrix_b    TEXT,
    b_args      TEXT,
    matrix_out  TEXT,
    out_args    TEXT
)
RETURNS MADLIB_SCHEMA.matrix_result AS $$
    PythonFunctionBodyOnly(`linalg', `matrix_ops')
    matrix_ops.matrix_sub(schema_madlib,
        matrix_a, a_args,
        matrix_b, b_args,
        matrix_out, out_args)
    return [matrix_out]
$$ LANGUAGE plpythonu
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `MODIFIES SQL DATA', `');

CREATE OR REPLACE FUNCTION
MADLIB_SCHEMA.matrix_sub
(
    matrix_a    TEXT,
    a_args      TEXT,
    matrix_b    TEXT,
    b_args      TEXT,
    matrix_out  TEXT
)
RETURNS MADLIB_SCHEMA.matrix_result AS $$
    SELECT MADLIB_SCHEMA.matrix_sub($1, $2, $3, $4, $5, ''::TEXT)
$$ LANGUAGE SQL
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `MODIFIES SQL DATA', `');


CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.matrix_sub(
    message     TEXT
) RETURNS TEXT AS $$
PythonFunction(linalg, matrix_help_message, matrix_sub_help_message)
$$ LANGUAGE plpythonu IMMUTABLE
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `CONTAINS SQL', `');

CREATE OR REPLACE FUNCTION
MADLIB_SCHEMA.matrix_sub
(
    matrix_a        TEXT,
    a_args          TEXT,
    matrix_b        TEXT,
    b_args          TEXT,
    matrix_out      TEXT
)
RETURNS MADLIB_SCHEMA.matrix_result AS $$
    SELECT
        MADLIB_SCHEMA.matrix_sub(
            $1, $2, $3, $4, $5, NULL);
$$ LANGUAGE sql
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `MODIFIES SQL DATA', `');


CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.matrix_sub()
RETURNS TEXT AS $$
BEGIN
    RETURN MADLIB_SCHEMA.matrix_sub('');
END;
$$ LANGUAGE plpgsql IMMUTABLE
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `CONTAINS SQL', `');
-------------------------------------------------------------------------

/**
 * @brief Extract row from matrix given row index. It requires that all the values
 * are NON-NULL. This is the dense or sparse representation of the matrix where the
 * matrix elements are indexed by row id for dense and by the row and column id for
 * sparse.
 *
 * @param matrix_in Name of the table containing the matrix
 * @param in_args A string containing multiple named arguments of the form "name=value".
 * This argument is used as a container for multiple parameters related to a single
 * matrix.
 * @param index Row index for wanted.
 * @returns Vector containing given row elements.
 *
 */
CREATE OR REPLACE FUNCTION
MADLIB_SCHEMA.matrix_extract_row
(
    matrix_in    TEXT,
    in_args      TEXT,
    index        INTEGER
)
RETURNS FLOAT8[] AS $$
    PythonFunctionBodyOnly(`linalg', `matrix_ops')
    return matrix_ops.matrix_extract(
        schema_madlib, matrix_in, in_args, 1, index)
$$ LANGUAGE plpythonu
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `MODIFIES SQL DATA', `');

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.matrix_extract_row(
    message     TEXT
) RETURNS TEXT AS $$
PythonFunction(linalg, matrix_help_message, matrix_extract_row_help_message)
$$ LANGUAGE plpythonu IMMUTABLE
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `CONTAINS SQL', `');

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.matrix_extract_row()
RETURNS TEXT AS $$
BEGIN
    RETURN MADLIB_SCHEMA.matrix_extract_row('');
END;
$$ LANGUAGE plpgsql IMMUTABLE
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `CONTAINS SQL', `');
-------------------------------------------------------------------------


/**
 * @brief Extract column from matrix given column index. It requires that all the values
 * are NON-NULL. This is the dense or sparse representation of the matrix where the
 * matrix elements are indexed by row id for dense and by the row and column id for
 * sparse.
 *
 * @param matrix_in Name of the table containing the matrix
 * @param in_args A string containing multiple named arguments of the form "name=value".
 * This argument is used as a container for multiple parameters related to a single
 * matrix.
 * @param index Column index for wanted.
 * @returns Vector containing given column elements.
 *
 */
CREATE OR REPLACE FUNCTION
MADLIB_SCHEMA.matrix_extract_col
(
    matrix_in    TEXT,
    in_args      TEXT,
    index        INTEGER
)
RETURNS FLOAT8[] AS $$
    PythonFunctionBodyOnly(`linalg', `matrix_ops')
    return matrix_ops.matrix_extract(
        schema_madlib, matrix_in, in_args, 2, index)
$$ LANGUAGE plpythonu
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `MODIFIES SQL DATA', `');

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.matrix_extract_col(
    message     TEXT
) RETURNS TEXT AS $$
PythonFunction(linalg, matrix_help_message, matrix_extract_col_help_message)
$$ LANGUAGE plpythonu IMMUTABLE
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `CONTAINS SQL', `');

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.matrix_extract_col()
RETURNS TEXT AS $$
BEGIN
    RETURN MADLIB_SCHEMA.matrix_extract_col('');
END;
$$ LANGUAGE plpgsql IMMUTABLE
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `CONTAINS SQL', `');
-------------------------------------------------------------------------


/**
 * @brief Get max value along dimension from matrix. Also returns corresponding index if set fetch_index.
 * It requires that all the values are NON-NULL. This is the dense or sparse representation of
 * the matrix where the matrix elements are indexed by row id for dense and by the row and column id for
 * sparse.
 *
 * @param matrix_in Name of the table containing the matrix
 * @param in_args A string containing multiple named arguments of the form "name=value".
 * This argument is used as a container for multiple parameters related to a single
 * matrix.
 * @param dim Which dimension to collapse. 1 means row wise, and 2 means column wise
 * @param matrix_out Result matrix which contains one column: max, and another column: index if fetch_index is set.
 * The type of column is array
 * @param fetch_index True when want to get corresponding index of max value. Default is false
 * @returns matrix_out.
 *
 */
CREATE OR REPLACE FUNCTION
MADLIB_SCHEMA.matrix_max
(
    matrix_in      TEXT,
    in_args        TEXT,
    dim            INTEGER,
    matrix_out     TEXT,
    fetch_index    BOOLEAN
)
RETURNS MADLIB_SCHEMA.matrix_result AS $$
    PythonFunctionBodyOnly(`linalg', `matrix_ops')
    matrix_ops.matrix_max(schema_madlib,
        matrix_in, in_args, dim, matrix_out, fetch_index)
    return [matrix_out]
$$ LANGUAGE plpythonu
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `MODIFIES SQL DATA', `');

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.matrix_max(
    message     TEXT
) RETURNS TEXT AS $$
PythonFunction(linalg, matrix_help_message, matrix_max_help_message)
$$ LANGUAGE plpythonu IMMUTABLE
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `CONTAINS SQL', `');

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.matrix_max()
RETURNS TEXT AS $$
BEGIN
    RETURN MADLIB_SCHEMA.matrix_max('');
END;
$$ LANGUAGE plpgsql IMMUTABLE
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `CONTAINS SQL', `');
-------------------------------------------------------------------------


/**
 * @brief Get min value along dimension from matrix. Also returns corresponding index if set fetch_index.
 * It requires that all the values are NON-NULL. This is the dense or sparse representation of
 * the matrix where the matrix elements are indexed by row id for dense and by the row and column id for
 * sparse.
 *
 * @param matrix_in Name of the table containing the matrix
 * @param in_args A string containing multiple named arguments of the form "name=value".
 * This argument is used as a container for multiple parameters related to a single
 * matrix.
 * @param dim Which dimension to collapse. 1 means row wise, and 2 means column wise
 * @param matrix_out Result matrix which contains one column: min, and another column: index if fetch_index is set.
 * The type of column is array
 * @param fetch_index True when want to get corresponding index of min value. Default is false
 * @returns matrix_out.
 *
 */
CREATE OR REPLACE FUNCTION
MADLIB_SCHEMA.matrix_min
(
    matrix_in      TEXT,
    in_args        TEXT,
    dim            INTEGER,
    matrix_out     TEXT,
    fetch_index    BOOLEAN
)
RETURNS MADLIB_SCHEMA.matrix_result AS $$
    PythonFunctionBodyOnly(`linalg', `matrix_ops')
    matrix_ops.matrix_min(schema_madlib,
        matrix_in, in_args, dim, matrix_out, fetch_index)
    return [matrix_out]
$$ LANGUAGE plpythonu
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `MODIFIES SQL DATA', `');

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.matrix_min(
    message     TEXT
) RETURNS TEXT AS $$
PythonFunction(linalg, matrix_help_message, matrix_min_help_message)
$$ LANGUAGE plpythonu IMMUTABLE
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `CONTAINS SQL', `');

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.matrix_min()
RETURNS TEXT AS $$
BEGIN
    RETURN MADLIB_SCHEMA.matrix_min('');
END;
$$ LANGUAGE plpgsql IMMUTABLE
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `CONTAINS SQL', `');
-------------------------------------------------------------------------


/**
 * @brief Calculate sum along dimension for matrix. It requires that all the values are NON-NULL.
 * This is the sparse representation of the matrix where the matrix elements
 * are indexed by the row and column id.
 *
 * @param matrix_in Name of the table containing the matrix
 * @param in_args Name-value pair string containing options for matrix_in
 * @param dim Which dimension to collapse. 1 means row wise, and 2 means column wise
 *
 */
CREATE OR REPLACE FUNCTION
MADLIB_SCHEMA.matrix_sum
(
    matrix_in      TEXT,
    in_args        TEXT,
    dim            INTEGER
)
RETURNS FLOAT8[] AS $$
    PythonFunctionBodyOnly(`linalg', `matrix_ops')
    return matrix_ops.matrix_sum(schema_madlib,
        matrix_in, in_args, dim)
$$ LANGUAGE plpythonu
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `MODIFIES SQL DATA', `');

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.matrix_sum(
    message     TEXT
) RETURNS TEXT AS $$
PythonFunction(linalg, matrix_help_message, matrix_sum_help_message)
$$ LANGUAGE plpythonu IMMUTABLE
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `CONTAINS SQL', `');

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.matrix_sum()
RETURNS TEXT AS $$
BEGIN
    RETURN MADLIB_SCHEMA.matrix_sum('');
END;
$$ LANGUAGE plpgsql IMMUTABLE
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `CONTAINS SQL', `');
-------------------------------------------------------------------------


/**
 * @brief Calculate mean along dimension for matrix. It requires that all the values are NON-NULL.
 * This is the sparse representation of the matrix where the matrix elements
 * are indexed by the row and column id.
 *
 * @param matrix_in Name of the table containing the matrix
 * @param in_args Name-value pair string containing options for matrix_in
 * @param dim Which dimension to collapse. 1 means row wise, and 2 means column wise
 *
 */
CREATE OR REPLACE FUNCTION
MADLIB_SCHEMA.matrix_mean
(
    matrix_in      TEXT,
    in_args        TEXT,
    dim            INTEGER
)
RETURNS FLOAT8[] AS $$
    PythonFunctionBodyOnly(`linalg', `matrix_ops')
    return matrix_ops.matrix_mean(schema_madlib,
        matrix_in, in_args, dim)
$$ LANGUAGE plpythonu
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `MODIFIES SQL DATA', `');

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.matrix_mean(
    message     TEXT
) RETURNS TEXT AS $$
PythonFunction(linalg, matrix_help_message, matrix_mean_help_message)
$$ LANGUAGE plpythonu IMMUTABLE
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `CONTAINS SQL', `');

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.matrix_mean()
RETURNS TEXT AS $$
BEGIN
    RETURN MADLIB_SCHEMA.matrix_mean('');
END;
$$ LANGUAGE plpgsql IMMUTABLE
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `CONTAINS SQL', `');
-------------------------------------------------------------------------


/**
 * @brief Multiplies one matrix with scalar. It requires that all the values are NON-NULL.
 * This is the sparse representation of the matrix where the matrix elements
 * are indexed by the row and column id.
 *
 * @param matrix_in Name of the table containing the matrix
 * @param in_args Name-value pair string containing options for matrix_in
 * @param scalar Scalar value used to be multiplied with matrix_in
 * @param matrix_out Name of the table where to output the result matrix
 * @param out_args Name-value pair string containing options for matrix_in
 * @returns Name of the table containing the result matrix
 *
 */
CREATE OR REPLACE FUNCTION
MADLIB_SCHEMA.matrix_scalar_mult
(
    matrix_in      TEXT,
    in_args        TEXT,
    scalar         FLOAT8,
    matrix_out     TEXT,
    out_args       TEXT
)
RETURNS MADLIB_SCHEMA.matrix_result AS $$
    PythonFunctionBodyOnly(`linalg', `matrix_ops')
    matrix_ops.matrix_scalar_mult(schema_madlib,
        matrix_in, in_args, scalar, matrix_out, out_args)
    return [matrix_out]
$$ LANGUAGE plpythonu
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `MODIFIES SQL DATA', `');

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.matrix_scalar_mult(
    message     TEXT
) RETURNS TEXT AS $$
PythonFunction(linalg, matrix_help_message, matrix_scalar_mult_help_message)
$$ LANGUAGE plpythonu IMMUTABLE
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `CONTAINS SQL', `');

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.matrix_scalar_mult()
RETURNS TEXT AS $$
BEGIN
    RETURN MADLIB_SCHEMA.matrix_scalar_mult('');
END;
$$ LANGUAGE plpgsql IMMUTABLE
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `CONTAINS SQL', `');
-------------------------------------------------------------------------

/**
 * @brief Multiplies one matrix with vector. It requires that all the values are NON-NULL.
 * This is the sparse representation of the matrix where the matrix elements
 * are indexed by the row and column id.
 *
 * @param matrix_in Name of the table containing the matrix
 * @param in_args Name-value pair string containing options for matrix_in
 * @param vector Vector value used to be multiplied with matrix_in
 * @returns Column vector which is the result of matrix_in * vector
 *
 */
CREATE OR REPLACE FUNCTION
MADLIB_SCHEMA.matrix_vec_mult
(
    matrix_in      TEXT,
    in_args        TEXT,
    vector         FLOAT8[]
)
RETURNS FLOAT8[] AS $$
    PythonFunctionBodyOnly(`linalg', `matrix_ops')
    return matrix_ops.matrix_vec_mult(schema_madlib,
        matrix_in, in_args, vector)
$$ LANGUAGE plpythonu
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `MODIFIES SQL DATA', `');

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.matrix_vec_mult(
    message     TEXT
) RETURNS TEXT AS $$
PythonFunction(linalg, matrix_help_message, matrix_vec_mult_help_message)
$$ LANGUAGE plpythonu IMMUTABLE
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `CONTAINS SQL', `');

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.matrix_vec_mult()
RETURNS TEXT AS $$
BEGIN
    RETURN MADLIB_SCHEMA.matrix_vec_mult('');
END;
$$ LANGUAGE plpgsql IMMUTABLE
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `CONTAINS SQL', `');
-------------------------------------------------------------------------


--TODO
/**
 * @brief Convert a matrix in (row_id, col_id, val) format(psarse matrix) to a matrix in (row_id, svec) format(svec matrix)
 * It requires that all the values are NOT-NULL. 
 * @param matrix_in Name of the table containing the input sparse matrix
 * @param in_row Name of the column containing the row index for the input matrix
 * @param in_col Name of the column containing the col index for the input matrix
 * @param in_val Name of the column containing the value of (row_id, col_id) for the input matrix
 * @param matrix_out Name of the table where to output the result matrix
 * @returns Name of the table containing the result svec matrix
 */

CREATE OR REPLACE FUNCTION
MADLIB_SCHEMA.matrix_sparse_to_svec
(
    matrix_in       TEXT,
    in_args         TEXT,
    matrix_out      TEXT,
    out_args        TEXT
)
RETURNS MADLIB_SCHEMA.matrix_result AS $$
    PythonFunctionBodyOnly(`linalg', `matrix_ops')
    matrix_ops.matrix_sparse_to_svec(schema_madlib,
        matrix_in, in_args,
        matrix_out, out_args)
    return [matrix_out]
$$ LANGUAGE plpythonu
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `MODIFIES SQL DATA', `');

CREATE OR REPLACE FUNCTION
MADLIB_SCHEMA.matrix_sparse_to_svec
(
    matrix_in       TEXT,
    in_args         TEXT,
    matrix_out      TEXT
)
RETURNS MADLIB_SCHEMA.matrix_result AS $$
    SELECT MADLIB_SCHEMA.matrix_sparse_to_svec($1, $2, $3, ''::TEXT)
$$ LANGUAGE SQL
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `MODIFIES SQL DATA', `');


CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.matrix_sparse_to_svec(
    message     TEXT
) RETURNS TEXT AS $$
PythonFunction(linalg, matrix_help_message, matrix_sparse_to_svec_help_message)
$$ LANGUAGE plpythonu IMMUTABLE
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `CONTAINS SQL', `');


CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.matrix_sparse_to_svec()
RETURNS TEXT AS $$
BEGIN
    RETURN MADLIB_SCHEMA.matrix_sparse_to_svec('');
END;
$$ LANGUAGE plpgsql IMMUTABLE
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `CONTAINS SQL', `');
-------------------------------------------------------------------------

--TODO
/**
 * @brief Convert a matrix in (row_id, svec) format(svec matrix) to a matrix in (row_id, col_id, value) format(sparse matrix)
 * It requires that all the values are NOT-NULL. 
 * @param matrix_in Name of the table containing the input svec matrix
 * @param in_row Name of the column containing the row index for the input matrix
 * @param in_svec Name of the column containing the svec format column for the input matrix
 * @param matrix_out Name of the table where to output the result matrix
 * @returns Name of the table containing the result sparse matrix
 */

CREATE OR REPLACE FUNCTION
MADLIB_SCHEMA.matrix_svec_to_sparse
(
    matrix_in       TEXT,
    in_args         TEXT,
    matrix_out      TEXT,
    out_args        TEXT
)
RETURNS MADLIB_SCHEMA.matrix_result AS $$
    PythonFunctionBodyOnly(`linalg', `matrix_ops')
    matrix_ops.matrix_svec_to_sparse(schema_madlib,
        matrix_in, in_args,
        matrix_out, out_args)
    return [matrix_out]
$$ LANGUAGE plpythonu
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `MODIFIES SQL DATA', `');

CREATE OR REPLACE FUNCTION
MADLIB_SCHEMA.matrix_svec_to_sparse
(
    matrix_in       TEXT,
    in_args         TEXT,
    matrix_out      TEXT
)
RETURNS MADLIB_SCHEMA.matrix_result AS $$
    SELECT MADLIB_SCHEMA.matrix_svec_to_sparse($1, $2, $3, ''::TEXT)
$$ LANGUAGE SQL
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `MODIFIES SQL DATA', `');


CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.matrix_svec_to_sparse(
    message     TEXT
) RETURNS TEXT AS $$
PythonFunction(linalg, matrix_help_message, matrix_svec_to_sparse_help_message)
$$ LANGUAGE plpythonu IMMUTABLE
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `CONTAINS SQL', `');


CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.matrix_svec_to_sparse()
RETURNS TEXT AS $$
BEGIN
    RETURN MADLIB_SCHEMA.matrix_svec_to_sparse('');
END;
$$ LANGUAGE plpgsql IMMUTABLE
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `CONTAINS SQL', `');
-------------------------------------------------------------------------

--TODO
/**
 * @brief Convert a matrix in (row_id, row_vec) format(dense matrix) to a matrix in (row_id, svec) format(svec matrix)
 * It requires that all the values are NOT-NULL. 
 * @param matrix_in Name of the table containing the input dense matrix
 * @param in_row Name of the column containing the row index for the input matrix
 * @param in_vec Name of the column containing the array format column for the input matrix
 * @param matrix_out Name of the table where to output the result matrix
 * @returns Name of the table containing the result svec matrix
 */

CREATE OR REPLACE FUNCTION
MADLIB_SCHEMA.matrix_dense_to_svec
(
    matrix_in       TEXT,
    in_args         TEXT,
    matrix_out      TEXT,
    out_args        TEXT
)
RETURNS MADLIB_SCHEMA.matrix_result AS $$
    PythonFunctionBodyOnly(`linalg', `matrix_ops')
    matrix_ops.matrix_dense_to_svec(schema_madlib,
        matrix_in, in_args,
        matrix_out, out_args)
    return [matrix_out]
$$ LANGUAGE plpythonu
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `MODIFIES SQL DATA', `');

CREATE OR REPLACE FUNCTION
MADLIB_SCHEMA.matrix_dense_to_svec
(
    matrix_in       TEXT,
    in_args         TEXT,
    matrix_out      TEXT
)
RETURNS MADLIB_SCHEMA.matrix_result AS $$
    SELECT MADLIB_SCHEMA.matrix_dense_to_svec($1, $2, $3, ''::TEXT)
$$ LANGUAGE SQL
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `MODIFIES SQL DATA', `');


CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.matrix_dense_to_svec(
    message     TEXT
) RETURNS TEXT AS $$
PythonFunction(linalg, matrix_help_message, matrix_dense_to_svec_help_message)
$$ LANGUAGE plpythonu IMMUTABLE
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `CONTAINS SQL', `');


CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.matrix_dense_to_svec()
RETURNS TEXT AS $$
BEGIN
    RETURN MADLIB_SCHEMA.matrix_dense_to_svec('');
END;
$$ LANGUAGE plpgsql IMMUTABLE
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `CONTAINS SQL', `');
-------------------------------------------------------------------------
--TODO
/**
 * @brief Convert a matrix in (row_id, svec) format(svec matrix) to a matrix in (row_id, row_vec) format(dense matrix)
 * It requires that all the values are NOT-NULL. 
 * @param matrix_in Name of the table containing the input svec matrix
 * @param in_row Name of the column containing the row index for the input matrix
 * @param in_vec Name of the column containing the svec format column for the input matrix
 * @param matrix_out Name of the table where to output the result matrix
 * @returns Name of the table containing the result dense matrix
 */

CREATE OR REPLACE FUNCTION
MADLIB_SCHEMA.matrix_svec_to_dense
(
    matrix_in       TEXT,
    in_args         TEXT,
    matrix_out      TEXT,
    out_args        TEXT
)
RETURNS MADLIB_SCHEMA.matrix_result AS $$
    PythonFunctionBodyOnly(`linalg', `matrix_ops')
    matrix_ops.matrix_svec_to_dense(schema_madlib,
        matrix_in, in_args,
        matrix_out, out_args)
    return [matrix_out]
$$ LANGUAGE plpythonu
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `MODIFIES SQL DATA', `');

CREATE OR REPLACE FUNCTION
MADLIB_SCHEMA.matrix_svec_to_dense
(
    matrix_in       TEXT,
    in_args         TEXT,
    matrix_out      TEXT
)
RETURNS MADLIB_SCHEMA.matrix_result AS $$
    SELECT MADLIB_SCHEMA.matrix_svec_to_dense($1, $2, $3, ''::TEXT)
$$ LANGUAGE SQL
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `MODIFIES SQL DATA', `');


CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.matrix_svec_to_dense(
    message     TEXT
) RETURNS TEXT AS $$
PythonFunction(linalg, matrix_help_message, matrix_svec_to_dense_help_message)
$$ LANGUAGE plpythonu IMMUTABLE
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `CONTAINS SQL', `');


CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.matrix_svec_to_dense()
RETURNS TEXT AS $$
BEGIN
    RETURN MADLIB_SCHEMA.matrix_svec_to_dense('');
END;
$$ LANGUAGE plpgsql IMMUTABLE
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `CONTAINS SQL', `');
-------------------------------------------------------------------------

/**
 * @brief Multiplies two matrices by element. It requires that all the values are NON-NULL.
 * This is the sparse representation of the matrix where the matrix elements
 * are indexed by the row and column id.
 *
 * @param matrix_a Name of the table containing the first matrix
 * @param a_row Name of the column containing the row id for the first matrix
 * @param a_col Name of the column containing the column id for the first matrix
 * @param a_val Name of the column containing the matrix values for the first matrix
 * @param matrix_b Name of the table containing the second matrix
 * @param b_row Name of the column containing the row id for the second matrix
 * @param b_col Name of the column containing the column id for the second matrix
 * @param b_val Name of the column containing the matrix values for the second matrix
 * @param matrix_out Name of the table where to output the result matrix
 * @returns Name of the table containing the result matrix
 *
 */
CREATE OR REPLACE FUNCTION
MADLIB_SCHEMA.matrix_elem_mult
(
    matrix_a    TEXT,
    a_args      TEXT,
    matrix_b    TEXT,
    b_args      TEXT,
    matrix_out  TEXT,
    out_args    TEXT
)
RETURNS MADLIB_SCHEMA.matrix_result AS $$
    PythonFunctionBodyOnly(`linalg', `matrix_ops')
    matrix_ops.matrix_elem_mult(schema_madlib,
        matrix_a, a_args,
        matrix_b, b_args,
        matrix_out, out_args)
    return [matrix_out]
$$ LANGUAGE plpythonu
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `MODIFIES SQL DATA', `');

CREATE OR REPLACE FUNCTION
MADLIB_SCHEMA.matrix_elem_mult
(
    matrix_a    TEXT,
    a_args      TEXT,
    matrix_b    TEXT,
    b_args      TEXT,
    matrix_out  TEXT
)
RETURNS MADLIB_SCHEMA.matrix_result AS $$
    SELECT MADLIB_SCHEMA.matrix_elem_mult($1, $2, $3, $4, $5, ''::TEXT)
$$ LANGUAGE SQL
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `MODIFIES SQL DATA', `');


CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.matrix_elem_mult(
    message     TEXT
) RETURNS TEXT AS $$
PythonFunction(linalg, matrix_help_message, matrix_elem_mult_help_message)
$$ LANGUAGE plpythonu IMMUTABLE
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `CONTAINS SQL', `');

CREATE OR REPLACE FUNCTION
MADLIB_SCHEMA.matrix_elem_mult
(
    matrix_a        TEXT,
    a_args          TEXT,
    matrix_b        TEXT,
    b_args          TEXT,
    matrix_out      TEXT
)
RETURNS MADLIB_SCHEMA.matrix_result AS $$
    SELECT
        MADLIB_SCHEMA.matrix_elem_mult(
            $1, $2, $3, $4, $5, NULL);
$$ LANGUAGE sql
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `MODIFIES SQL DATA', `');


CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.matrix_elem_mult()
RETURNS TEXT AS $$
BEGIN
    RETURN MADLIB_SCHEMA.matrix_elem_mult('');
END;
$$ LANGUAGE plpgsql IMMUTABLE
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `CONTAINS SQL', `');

-------------------------------------------------------------------------

/**
 * @brief Transpose matrix. It requires that all the values are NON-NULL.
 * This is the sparse representation of the matrix where the matrix elements
 * are indexed by the row and column index.
 *
 * @param matrix_in Name of the table containing the input matrix
 * @param in_row Name of the column containing the row index for the input matrix
 * @param in_col Name of the column containing the column index for the input matrix
 * @param in_val Name of the column containing the matrix values for the input matrix
 * @param matrix_out Name of the table where to output the result matrix
 * @param use_temp_table Specify if use temp table for result
 * @returns Name of the table containing the result matrix
 *
 */
CREATE OR REPLACE FUNCTION
MADLIB_SCHEMA.matrix_trans
(
    matrix_in      TEXT,
    in_args        TEXT,
    matrix_out     TEXT,
    out_args       TEXT,
    use_temp_table BOOLEAN
)
RETURNS MADLIB_SCHEMA.matrix_result AS $$
    PythonFunctionBodyOnly(`linalg', `matrix_ops')
    matrix_ops.matrix_trans(schema_madlib,
        matrix_in, in_args, matrix_out, out_args)
    return [matrix_out]
$$ LANGUAGE plpythonu
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `MODIFIES SQL DATA', `');

CREATE OR REPLACE FUNCTION
MADLIB_SCHEMA.matrix_trans
(
    matrix_in       TEXT,
    in_args         TEXT,
    matrix_out      TEXT,
    out_args        TEXT
)
RETURNS MADLIB_SCHEMA.matrix_result AS $$
    SELECT
        MADLIB_SCHEMA.matrix_trans(
            $1, $2, $3, $4, FALSE);
$$ LANGUAGE sql
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `MODIFIES SQL DATA', `');

CREATE OR REPLACE FUNCTION
MADLIB_SCHEMA.matrix_trans
(
    matrix_in       TEXT,
    in_args         TEXT,
    matrix_out      TEXT
)
RETURNS MADLIB_SCHEMA.matrix_result AS $$
    SELECT
        MADLIB_SCHEMA.matrix_trans(
            $1, $2, $3, NULL, FALSE);
$$ LANGUAGE sql
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `MODIFIES SQL DATA', `');

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.matrix_trans(
    message     TEXT
) RETURNS TEXT AS $$
PythonFunction(linalg, matrix_help_message, matrix_trans_help_message)
$$ LANGUAGE plpythonu IMMUTABLE
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `CONTAINS SQL', `');

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.matrix_trans()
RETURNS TEXT AS $$
BEGIN
    RETURN MADLIB_SCHEMA.matrix_trans('');
END;
$$ LANGUAGE plpgsql IMMUTABLE
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `CONTAINS SQL', `');
-------------------------------------------------------------------------
/**
 * @brief Converts matrix to sparse representation. It requires that all the values are NON-NULL.
 * This is the dense representation of the matrix where the matrix elements
 * are indexed by the row and column index.
 *
 * @param matrix_in Name of the table containing the input matrix
 * @param matrix_out Name of the table where to output the result matrix
 * @param use_temp_table Specify if use temp table for result
 * @returns Name of the table containing the result matrix
 *
 */

CREATE OR REPLACE FUNCTION
MADLIB_SCHEMA.matrix_sparsify
(
    matrix_in       TEXT,
    in_args         TEXT,
    matrix_out      TEXT,
    out_args        TEXT,
    use_temp_table  BOOLEAN
)
RETURNS MADLIB_SCHEMA.matrix_result AS $$
    PythonFunctionBodyOnly(`linalg', `matrix_ops')
    matrix_ops.matrix_sparsify(schema_madlib, matrix_in, in_args, matrix_out,
                               out_args, use_temp_table)
    return [matrix_out]
$$ LANGUAGE plpythonu
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `MODIFIES SQL DATA', `');

/* Overloaded function */
CREATE OR REPLACE FUNCTION
MADLIB_SCHEMA.matrix_sparsify
(
    matrix_in       TEXT,
    in_args         TEXT,
    matrix_out      TEXT,
    out_args        TEXT
)
RETURNS MADLIB_SCHEMA.matrix_result AS $$
    SELECT MADLIB_SCHEMA.matrix_sparsify($1, $2, $3, $4, FALSE);
$$ LANGUAGE SQL
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `MODIFIES SQL DATA', `');

/* Overloaded function */
CREATE OR REPLACE FUNCTION
MADLIB_SCHEMA.matrix_sparsify
(
    matrix_in       TEXT,
    in_args         TEXT,
    matrix_out      TEXT
)
RETURNS MADLIB_SCHEMA.matrix_result AS $$
    SELECT MADLIB_SCHEMA.matrix_sparsify($1, $2, $3, '', FALSE);
$$ LANGUAGE SQL
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `MODIFIES SQL DATA', `');

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.matrix_sparsify(
    message     TEXT
) RETURNS TEXT AS $$
PythonFunction(linalg, matrix_help_message, matrix_sparsify_help_message)
$$ LANGUAGE plpythonu IMMUTABLE
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `CONTAINS SQL', `');


CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.matrix_sparsify()
RETURNS TEXT AS $$
BEGIN
    RETURN MADLIB_SCHEMA.matrix_sparsify('');
END;
$$ LANGUAGE plpgsql IMMUTABLE
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `CONTAINS SQL', `');
-------------------------------------------------------------------------
/**
 * @brief Converts matrix to dense representation. It requires that all the values are NON-NULL.
 * This is the sparse representation of the matrix where the matrix elements
 * are indexed by the row index.
 *
 * @param matrix_in Name of the table containing the input matrix
 * @param in_row Name of the column containing the row index for the input matrix
 * @param in_col Name of the column containing the column index for the input matrix
 * @param in_val Name of the column containing the matrix values for the input matrix
 * @param matrix_out Name of the table where to output the result matrix
 * @param use_temp_table Specify if use temp table for result
 * @returns Name of the table containing the result matrix
 *
 */

CREATE OR REPLACE FUNCTION
MADLIB_SCHEMA.matrix_densify
(
    matrix_in       TEXT,
    in_args         TEXT,
    matrix_out      TEXT,
    out_args        TEXT,
    use_temp_table  BOOLEAN
)
RETURNS MADLIB_SCHEMA.matrix_result AS $$
    PythonFunctionBodyOnly(`linalg', `matrix_ops')
    matrix_ops.matrix_densify(schema_madlib,
        matrix_in, in_args, matrix_out, out_args, use_temp_table)
    return [matrix_out]
$$ LANGUAGE plpythonu
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `MODIFIES SQL DATA', `');

/* Overloaded function*/
CREATE OR REPLACE FUNCTION
MADLIB_SCHEMA.matrix_densify
(
    matrix_in       TEXT,
    in_args         TEXT,
    matrix_out      TEXT,
    out_args        TEXT
)
RETURNS MADLIB_SCHEMA.matrix_result AS $$
    SELECT MADLIB_SCHEMA.matrix_densify($1, $2, $3, $4, FALSE);
$$ LANGUAGE SQL
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `MODIFIES SQL DATA', `');

CREATE OR REPLACE FUNCTION
MADLIB_SCHEMA.matrix_densify
(
    matrix_in       TEXT,
    in_args         TEXT,
    matrix_out      TEXT
)
RETURNS MADLIB_SCHEMA.matrix_result AS $$
    SELECT MADLIB_SCHEMA.matrix_densify($1, $2, $3, '', FALSE);
$$ LANGUAGE SQL
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `MODIFIES SQL DATA', `');

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.matrix_densify(
    message     TEXT
) RETURNS TEXT AS $$
PythonFunction(linalg, matrix_help_message, matrix_densify_help_message)
$$ LANGUAGE plpythonu IMMUTABLE
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `CONTAINS SQL', `');


CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.matrix_densify()
RETURNS TEXT AS $$
BEGIN
    RETURN MADLIB_SCHEMA.matrix_densify('');
END;
$$ LANGUAGE plpgsql IMMUTABLE
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `CONTAINS SQL', `');
-------------------------------------------------------------------------

------------------ Scale and add matrices  ------------------------------
/**
 * @brief Scale and add matrix operation ( R <- A + sB)
 *
 * @param matrix_a Source matrix table A (dense matrix format)
 * @param matrix_b Source matrix table B (dense matrix format)
 * @param scale    Scale for matrix B
 * @param matrix_out Output table for matrix R <- A + sB
 *
 * @return VOID
 *
 * @usage
 * For matrix addition and subtration, you can use the same function
 * with different values of scalar
 * <pre>
 * SELECT matrix_scale_and_add('matrix_a', 'matrix_b', 1, 'matrix_out');
 * SELECT matrix_scale_and_add('matrix_a', 'matrix_b', -1, 'matrix_out');
 * </pre>
 */

CREATE OR REPLACE FUNCTION  MADLIB_SCHEMA.matrix_scale_and_add(
    matrix_a    TEXT,
    a_args      TEXT,
    matrix_b    TEXT,
    b_args      TEXT,
    scale       DOUBLE PRECISION,
    matrix_out  TEXT,
    out_args    TEXT
)
RETURNS VOID AS $$
PythonFunction(linalg, matrix_ops, matrix_scale_and_add)
$$ LANGUAGE plpythonu
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `MODIFIES SQL DATA', `');


------------------ Matrix Norms ------------------------------

/**
 * @brief Compute matrix norm (of various types)
 *
 * @param matrix_a Source matrix table (dense matrix format)
 * @param norm_type Type of norm used (default: fro)
 *
 * @return DOUBLE PRECISION
 *
 * @usage Currenty, we support the following norms
 * (a) 'fro': Computes the frobenius norm
 *
 * <pre>
 * SELECT matrix_norm('<em>matrix_table_name</em>', 'fro');
 * </pre>
 */

CREATE OR REPLACE FUNCTION  MADLIB_SCHEMA.matrix_norm(
    matrix_in   TEXT,
    in_args     TEXT,
    norm_type   TEXT
)
RETURNS DOUBLE PRECISION AS $$
PythonFunction(linalg, matrix_ops, matrix_norm)
$$ LANGUAGE plpythonu
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `READS SQL DATA', `');

/**
 * @brief Compute matrix norm of fro
 *
 * @param matrix_a Source matrix table (dense matrix format)
 *
 * @return DOUBLE PRECISION
 *
 * @usage Currenty, we support the following norms
 * (a) 'fro': Computes the frobenius norm
 *
 * <pre>
 * SELECT matrix_norm('<em>matrix_table_name</em>', 'fro');
 * </pre>
 */

CREATE OR REPLACE FUNCTION
MADLIB_SCHEMA.matrix_norm(
    matrix_in    TEXT,
    in_args      TEXT
)
RETURNS DOUBLE PRECISION AS $$
    SELECT MADLIB_SCHEMA.matrix_norm($1, $2, NULL)
$$ LANGUAGE SQL
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `READS SQL DATA', `');
-------------------------------------------------------------------------


CREATE OR REPLACE FUNCTION
MADLIB_SCHEMA.matrix_block_mult
(
    matrix_a    TEXT,
    a_args      TEXT,
    matrix_b    TEXT,
    b_args      TEXT,
    matrix_out  TEXT,
    out_args    TEXT
)
RETURNS MADLIB_SCHEMA.matrix_result AS $$
    PythonFunctionBodyOnly(`linalg', `matrix_ops')
    matrix_ops.matrix_block_mult(schema_madlib, matrix_a, a_args,
                                 matrix_b, b_args, matrix_out, out_args)
    return [matrix_out]
$$ LANGUAGE plpythonu
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `MODIFIES SQL DATA', `');


CREATE OR REPLACE FUNCTION
MADLIB_SCHEMA.matrix_block_square
(
    matrix_in   TEXT,
    in_args     TEXT,
    matrix_out  TEXT,
    out_args    TEXT
)
RETURNS MADLIB_SCHEMA.matrix_result AS $$
    PythonFunctionBodyOnly(`linalg', `matrix_ops')
    matrix_ops.matrix_block_square(schema_madlib, matrix_in, in_args,
                                   matrix_out, out_args)
    return [matrix_out]
$$ LANGUAGE plpythonu
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `MODIFIES SQL DATA', `');


CREATE OR REPLACE FUNCTION
MADLIB_SCHEMA.matrix_block_trans
(
    matrix_in       TEXT,
    in_args         TEXT,
    matrix_out      TEXT,
    out_args        TEXT,
    use_temp_table  BOOLEAN
)
RETURNS MADLIB_SCHEMA.matrix_result AS $$
    PythonFunctionBodyOnly(`linalg', `matrix_ops')
    matrix_ops.matrix_block_trans(schema_madlib, matrix_in, in_args,
                                  matrix_out, out_args,
                                  use_temp_table=use_temp_table)
    return [matrix_out]
$$ LANGUAGE plpythonu
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `MODIFIES SQL DATA', `');


CREATE OR REPLACE FUNCTION
MADLIB_SCHEMA.matrix_block_trans
(
    matrix_in   TEXT,
    in_args     TEXT,
    matrix_out  TEXT,
    out_args    TEXT
)
RETURNS MADLIB_SCHEMA.matrix_result AS $$
    select MADLIB_SCHEMA.matrix_block_trans($1, $2, $3, $4, FALSE)
$$ LANGUAGE SQL
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `MODIFIES SQL DATA', `');

/**
 * @brief Calculate square of matrix. It requires that all the values are NON-NULL.
 * This is the dense representation of the matrix where the matrix elements
 * are indexed by the row index.
 *
 * @param matrix_in Name of the table containing the input matrix
 * @param matrix_out Name of the table where to output the result matrix
 * @returns Name of the table containing the result matrix
 *
 */
CREATE OR REPLACE FUNCTION
MADLIB_SCHEMA.matrix_square
(
    matrix_in   TEXT,
    in_args     TEXT,
    matrix_out  TEXT,
    out_args    TEXT
)
RETURNS MADLIB_SCHEMA.matrix_result AS $$
    PythonFunctionBodyOnly(`linalg', `matrix_ops')
    matrix_ops.matrix_square(schema_madlib, matrix_in, in_args,
                             matrix_out, out_args)
    return [matrix_out]
$$ LANGUAGE plpythonu
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `MODIFIES SQL DATA', `');


CREATE OR REPLACE FUNCTION
MADLIB_SCHEMA.matrix_square
(
    matrix_in   TEXT,
    in_args     TEXT,
    matrix_out  TEXT
)
RETURNS MADLIB_SCHEMA.matrix_result AS $$
    SELECT MADLIB_SCHEMA.matrix_square($1, $2, $3, ''::TEXT);
$$ LANGUAGE SQL
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `MODIFIES SQL DATA', `');
-------------------------------------------------------------------------
-------------------------------------------------------------------------
-------------------------------------------------------------------------

/* Internal functions */

CREATE OR REPLACE FUNCTION
MADLIB_SCHEMA.__rand_vector
(
    dim INTEGER
)
RETURNS INTEGER[]
AS 'MODULE_PATHNAME', 'rand_vector'
LANGUAGE C STRICT
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `NO SQL', `');


CREATE OR REPLACE FUNCTION
MADLIB_SCHEMA.__rand_block
(
    row_dim   INTEGER,
    col_dim   INTEGER
)
RETURNS INTEGER[]
AS 'MODULE_PATHNAME', 'rand_block'
LANGUAGE C STRICT
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `NO SQL', `');

CREATE OR REPLACE FUNCTION
MADLIB_SCHEMA.__rand_block
(
    dim INTEGER
)
RETURNS INTEGER[] AS $$
    SELECT MADLIB_SCHEMA.__rand_block($1, $1);
$$ LANGUAGE sql STRICT
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `CONTAINS SQL', `');

CREATE OR REPLACE FUNCTION
MADLIB_SCHEMA.__matrix_row_split
(
    row_in  FLOAT8[],
    size    INTEGER
)
RETURNS SETOF FLOAT8[]
AS 'MODULE_PATHNAME', 'row_split'
LANGUAGE C STRICT
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `NO SQL', `');

CREATE OR REPLACE FUNCTION
MADLIB_SCHEMA.__matrix_densify_sfunc
(
    state     FLOAT8[],
    col_dim   INTEGER,
    col_id    INTEGER,
    val       FLOAT8
)
RETURNS FLOAT8[]
AS 'MODULE_PATHNAME', 'matrix_densify_sfunc'
LANGUAGE C
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `NO SQL', `');

DROP AGGREGATE IF EXISTS
MADLIB_SCHEMA.__matrix_densify_agg
(
    INTEGER,    -- col_dim
    INTEGER,    -- col_id
    FLOAT8      -- value
);

CREATE AGGREGATE
MADLIB_SCHEMA.__matrix_densify_agg
(
    INTEGER,     -- col_dim
    INTEGER,     -- col_id
    FLOAT8       -- value
)
(
    stype = FLOAT8[],
    sfunc = MADLIB_SCHEMA.__matrix_densify_sfunc
);


CREATE OR REPLACE FUNCTION
MADLIB_SCHEMA.__matrix_blockize_sfunc
(
    state   FLOAT8[],
    row_id  INTEGER,
    row_vec FLOAT8[],
    rsize   INTEGER
)
RETURNS FLOAT8[]
AS 'MODULE_PATHNAME', 'matrix_blockize_sfunc'
LANGUAGE C
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `NO SQL', `');

DROP AGGREGATE IF EXISTS
MADLIB_SCHEMA.__matrix_blockize_agg
(
    INTEGER,    -- row_id
    FLOAT8[],   -- row_vec
    INTEGER     -- row_dim
);

CREATE AGGREGATE
MADLIB_SCHEMA.__matrix_blockize_agg
(
    INTEGER,    -- row_id
    FLOAT8[],   -- row_vec
    INTEGER     -- row_dim
)
(
    stype = FLOAT8[],
    sfunc = MADLIB_SCHEMA.__matrix_blockize_sfunc
);

CREATE OR REPLACE FUNCTION
MADLIB_SCHEMA.__matrix_unblockize_sfunc
(
    state           FLOAT8[],
    total_col_dim   INTEGER,
    col_id          INTEGER,
    row_vec         FLOAT8[]
)
RETURNS FLOAT8[]
AS 'MODULE_PATHNAME', 'matrix_unblockize_sfunc'
LANGUAGE C
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `NO SQL', `');

DROP AGGREGATE IF EXISTS
MADLIB_SCHEMA.__matrix_unblockize_agg
(
    INTEGER,    -- col_dim
    INTEGER,    -- col_id
    FLOAT8[]    -- row_vec
);

CREATE AGGREGATE
MADLIB_SCHEMA.__matrix_unblockize_agg
(
    INTEGER,    -- col_dim
    INTEGER,    -- col_id
    FLOAT8[]    -- row_vec
)
(
    stype = FLOAT8[],
    sfunc = MADLIB_SCHEMA.__matrix_unblockize_sfunc
);

CREATE OR REPLACE FUNCTION
MADLIB_SCHEMA.matrix_mem_mult
(
    matrix_a    FLOAT[],
    matrix_b    FLOAT[],
    trans_b     BOOLEAN
)
RETURNS FLOAT8[]
AS 'MODULE_PATHNAME', 'matrix_mem_mult'
LANGUAGE C
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `NO SQL', `');


CREATE OR REPLACE FUNCTION
MADLIB_SCHEMA.matrix_mem_mult
(
    matrix_a    FLOAT[],
    matrix_b    FLOAT[]
)
RETURNS FLOAT8[] AS $$
    SELECT MADLIB_SCHEMA.matrix_mem_mult($1, $2, false);
$$ LANGUAGE sql
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `CONTAINS SQL', `');

-- CREATE OR REPLACE FUNCTION
-- MADLIB_SCHEMA.matrix_vec_mem_mult
-- (
--     matrix_a    FLOAT[],
--     vector_b    FLOAT[]
-- )
-- RETURNS FLOAT8[]
-- AS 'MODULE_PATHNAME', 'matrix_vec_mem_mult'
-- $$ LANGUAGE C;


CREATE OR REPLACE FUNCTION
MADLIB_SCHEMA.matrix_mem_trans
(
    matrix    FLOAT[]
)
RETURNS FLOAT8[]
AS 'MODULE_PATHNAME', 'matrix_mem_trans'
LANGUAGE C
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `NO SQL', `');


CREATE OR REPLACE FUNCTION
MADLIB_SCHEMA.__matrix_mem_sum_sfunc
(
    state   FLOAT[],
    matrix  FLOAT[]
)
RETURNS FLOAT8[]
AS 'MODULE_PATHNAME', 'matrix_mem_sum_sfunc'
LANGUAGE C
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `NO SQL', `');

DROP AGGREGATE IF EXISTS
MADLIB_SCHEMA.__matrix_mem_sum
(
    FLOAT8[]
);

CREATE AGGREGATE
MADLIB_SCHEMA.__matrix_mem_sum
(
    FLOAT8[]
)
(
    stype = FLOAT8[],
    sfunc = MADLIB_SCHEMA.__matrix_mem_sum_sfunc
);


CREATE OR REPLACE FUNCTION
MADLIB_SCHEMA.__matrix_column_to_array_format
(
    matrix_in       TEXT,
    row_id          TEXT,
    matrix_out      TEXT,
    istemp          BOOLEAN
)
RETURNS MADLIB_SCHEMA.matrix_result AS $$
    PythonFunctionBodyOnly(`linalg', `matrix_ops')
    matrix_ops._matrix_column_to_array_format(matrix_in, row_id, matrix_out, istemp)
    return [matrix_out]
$$ LANGUAGE plpythonu STRICT
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `MODIFIES SQL DATA', `');


CREATE OR REPLACE FUNCTION
MADLIB_SCHEMA.matrix_blockize
(
    matrix_in       TEXT,
    in_args         TEXT,
    rsize           INTEGER,
    csize           INTEGER,
    matrix_out      TEXT,
    out_args        TEXT
)
RETURNS MADLIB_SCHEMA.matrix_result AS $$
    PythonFunctionBodyOnly(`linalg', `matrix_ops')
    matrix_ops.matrix_blockize(schema_madlib, matrix_in, in_args, rsize, csize, matrix_out, out_args)
    return [matrix_out]
$$ LANGUAGE plpythonu
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `MODIFIES SQL DATA', `');

CREATE OR REPLACE FUNCTION
MADLIB_SCHEMA.matrix_blockize
(
    matrix_in       TEXT,
    in_args         TEXT,
    rsize           INTEGER,
    csize           INTEGER,
    matrix_out      TEXT
)
RETURNS MADLIB_SCHEMA.matrix_result AS $$
    SELECT MADLIB_SCHEMA.matrix_blockize($1, $2, $3, $4, $5, ''::text)
$$ LANGUAGE SQL
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `MODIFIES SQL DATA', `');


CREATE OR REPLACE FUNCTION
MADLIB_SCHEMA.matrix_unblockize
(
    matrix_in   TEXT,
    in_args     TEXT,
    matrix_out  TEXT,
    out_args    TEXT
)
RETURNS MADLIB_SCHEMA.matrix_result AS $$
    PythonFunctionBodyOnly(`linalg', `matrix_ops')
    matrix_ops.matrix_unblockize(schema_madlib, matrix_in, in_args,
                                 matrix_out, out_args)
    return [matrix_out]
$$ LANGUAGE plpythonu
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `MODIFIES SQL DATA', `');


CREATE OR REPLACE FUNCTION
MADLIB_SCHEMA.__matrix_unnest_block
(
    block FLOAT8[]
)
RETURNS SETOF FLOAT8[]
AS 'MODULE_PATHNAME', 'unnest_block'
LANGUAGE C IMMUTABLE STRICT
m4_ifdef(`__HAS_FUNCTION_PROPERTIES__', `NO SQL', `');
